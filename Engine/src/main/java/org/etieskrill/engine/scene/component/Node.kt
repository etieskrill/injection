package org.etieskrill.engine.scene.component

import org.etieskrill.engine.graphics.Batch
import org.etieskrill.engine.input.Key
import org.etieskrill.engine.input.Keys
import org.joml.Vector2f
import org.joml.Vector4f
import org.joml.plusAssign

abstract class Node<T : Node<T>> {

    var position = Vector2f(0f)
        set(value) {
            field.set(value)
        }
    val absolutePosition: Vector2f
        get() {
            if (parent == null) return Vector2f(position)
            val parentPosition = parent!!.absolutePosition
            parentPosition += position
            return parentPosition
        }

    var size = Vector2f(100f)
        set(value) {
            field.set(value)
            invalidate()
        }

    var alignment = Alignment.TOP_LEFT
        set(value) {
            field = value
            invalidate()
        }
    var margin = Vector4f(0f) //Swizzle: top, bottom, left, right
        set(value) {
            field.set(value)
        }

    var isVisible = true

    protected var colour = Vector4f(0f)
        set(value) {
            field.set(value)
            renderedColour.set(value)
        }
    protected val renderedColour = Vector4f(0f)

    var parent: Node<*>? = null
        private set

    var focused: Boolean = false
        internal set
    var focusRequestCallback: ((Node<*>) -> Boolean)? = null

    private var shouldFormat = true

    enum class Alignment {
        FIXED_POSITION,

        TOP_LEFT, TOP, TOP_RIGHT,
        CENTER_LEFT, CENTER, CENTER_RIGHT,
        BOTTOM_LEFT, BOTTOM, BOTTOM_RIGHT
    }

    open fun update(delta: Double) = Unit

    open fun format() = Unit

    open fun render(batch: Batch) = Unit

    fun show() {
        isVisible = true
    }

    fun hide() {
        isVisible = false
    }

    protected fun setParent(parent: Node<*>?) {
        check(parent != this) { "A node may not be it's own parent" }
        checkRecursively({ it != this }) { "A node may not be it's own parent anywhere in the hierarchy" }

        this.parent = parent
        if (parent != null) invalidate()
    }

    private fun checkRecursively(condition: (Node<*>) -> Boolean, message: () -> String) {
        var parent = this as Node<*>
        while (parent.parent != null) {
            parent = parent.parent!!
            if (!condition(parent)) error(message())
        }
    }

    protected fun shouldFormat() =
        if (shouldFormat) {
            shouldFormat = false
            true
        } else {
            false
        }

    fun invalidate() {
        this.shouldFormat = true
        parent?.invalidate()
    }

    /**
     * Handle an event generated by a mouse click.
     *
     * This event is generated only for the root node. Every node may decide for itself whether this event hits the
     * node, is intercepted, and/or passed on to potential children.
     */
    open fun handleHit(button: Key, action: Keys.Action, posX: Double, posY: Double): Boolean {
        requestFocus()
        return false
    }

    open fun doesHit(posX: Double, posY: Double): Boolean {
        val absPos = absolutePosition
        return absPos.x() + size.x() >= posX && posX >= absPos.x() &&
                absPos.y() + size.y() >= posY && posY >= absPos.y()
    }

    /**
     * Handle an event generated by dragging (holding a button and moving) the mouse.
     *
     * > Currently, only the [primary mouse button][Keys.LEFT_MOUSE] will generate this event.
     *
     * This event is generated only for the root node. Every node may decide for itself whether this event hits the
     * node, is intercepted, and/or passed on to potential children.
     */
    //primary mouse key is just implied for now TODO detect any mouse key (do keyboard keys make sense?)
    open fun handleDrag(deltaX: Double, deltaY: Double, posX: Double, posY: Double) = false

    /**
     * Handle an event generated by a key press of any physical key, as mapped by [Keys] (GLFW).
     *
     * This event is generated only for the root node. Every node may decide for itself whether this event hits the
     * node, is intercepted, or passed on to potential children.
     */
    open fun handleKey(key: Key, action: Keys.Action) = false

    /**
     * Handle a character as generated by the OS's text input system. Usable e.g. for text input. The characters
     * generated take into account the locale, modifiers, and dead keys, and are encoded in UTF-16.
     *
     * This event is generated only for the currently focused node, or the root node by default. Every node may decide
     * for itself whether this event hits the node, is intercepted, or passed on to potential children.
     *
     * @see requestFocus
     */
    open fun handleCharacter(char: Char) = false

    private fun internalRequestFocus(node: Node<*>): Boolean =
        focusRequestCallback?.invoke(node)
            ?: parent?.internalRequestFocus(node)
            ?: false

    /**
     * Calling this method will request {@link Node this Node} to be focused. This means, that all non-cursor input
     * will be directed to this node instead of the hierarchy root.
     * <p>
     * By default, the root node will be in focus.
     *
     * @return whether the request was successful
     */
    fun requestFocus(): Boolean = internalRequestFocus(this)

}
